TA-LIB
https://alphascientist.com/feature_engineering.html
WAVELET TRANSFORMATION HERE ПОСМОТРЕТЬ СЛЕД ТРИ!!!
https://medium.com/analytics-vidhya/using-machine-learning-to-predict-stock-prices-c4d0b23b029a
https://medium.com/engineer-quant
https://github.com/VivekPa/AIAlpha



https://habr.com/ru/post/149077/ Сокеты в Python для начинающих
MUST TEST
1. + add HIGH, LOW, CLOSE, VOL, Скользящие средние
1.1. for white candle Low-Open, high - close, White color or black, open - close, high - low
1.2 день недули, месяца час  мин
1.3.средние
2. Candle Number
3. log(C(t)/C(t+1)) use Instead of delta... логарифм относительного приращения
   или просто C(t)/C(t+1)
4. Wavwlet decomposition ??? или ну его , сильно сложно и возможно неоправданно
5. Использовать ансамбль (например на разных интервалах, или архитектурах)
   10, 15, 30, 1H, 1D, 1W
6. Чем больше внутр нейронов тем выше риск переобучения
	- обучать и тестировать через несколько шагов обучения, пока производительность  не нвчнет падать
	- регуляризация
6. робот для торговли в одном направлении
7.графики нормальные, визуализация


ADX,ATR добавить в state!!?
http://bottlepy.org/docs/dev/tutorial.html#introducing-formsdict
https://habr.com/ru/post/250831/
http://python.su/forum/topic/7215/?page=1#post-48902
https://automated-testing.info/t/zametka-prostoj-i-udobnyj-web-framework-bottle/3973
https://habr.com/ru/post/221659/

http://o-s-a.net/os-engine.html
lisicin
lde@mail.ru
Su....3
https://jamesmccaffrey.wordpress.com/2018/03/06/using-a-neural-network-created-by-cntk-or-tensorflow-in-a-c-program/
разложить на шум сезонность и тренд 1 5 10 15 30 60 1D

Проверить стационарность

https://yandex.ru/search/?lr=213&text=Reinforcement%20Learning%3A%20With%20Open%20AI%2C%20TensorFlow%20and%20Keras%20Using%20Python%20pdf
https://github.com/topics/stock-price-prediction?o=desc&s=stars
https://towardsdatascience.com/neural-networks-to-predict-the-market-c4861b649371
построить пример https://www.quantinsti.com/blog/artificial-neural-network-python-using-keras-predicting-stock-price-movement?utm_campaign=News&utm_medium=Community&utm_source=DataCamp.com
посмотреть https://gitlab.com/doctorj/sairen/
Посмотреть обязательно reinforcement learning: I have been eying this paper: "A Deep Reinforcement Learning Framework for the Financial Portfolio" that you may enjoy, my hope is to build my own December 2018. Here is the authors accompanying Github repo for the project as well: https://github.com/ZhengyaoJiang/PGPortfolio
очень интересные комменты прочитать http://www.wildml.com/2018/02/introduction-to-learning-to-trade-with-reinforcement-learning/  и это прочитать из комментов https://arxiv.org/pdf/1710.02298.pdf

293045971 

https://github.com/germain-hug/Deep-RL-Keras

def gotnextstate(self)
		self.t += 1
		
        self.done = True if self.t>=len(self.data)-1 else False
		
        if self.args.candlenum:
            result += [self.data.index[self.t].day + 0.0, self.data.index[self.t].dayofweek+1 + 0.0,(self.data.index[self.t].hour*60 + self.data.index[self.t].minute -600 )/5 +1]

        
		
        if self.args.usevol:
            self.history_vol.pop(0)
            self.history_vol.append(self.data.iloc[self.t, :][datacol_vol] - self.data.iloc[(self.t - 1), :][
                datacol_vol])  # add the diferrence between cureent CLose Value and prior Close Value
            result+= self.history_vol


        if self.args.allprices:
			self.history.pop(0) # method takes a single argument (index) and removes the element present at that index from the list. ...
			self.history.append(self.data.iloc[self.t, :][datacol] - self.data.iloc[(self.t - 1), :][
            datacol])  # add the diferrence between cureent CLose Value and prior Close Value
			result +=self.history	
			
            self.open_vol.pop(0)
            self.open_vol.append(self.data.iloc[self.t, :][opencol] - self.data.iloc[(self.t - 1), :][
                opencol])  # add the diferrence between cureent CLose Value and prior Close Value
            result += self.open_vol

            self.high_vol.pop(0)
            self.high_vol.append(self.data.iloc[self.t, :][highcol] - self.data.iloc[(self.t - 1), :][
                highcol])  # add the diferrence between cureent CLose Value and prior Close Value
            result += self.high_vol

            self.low_vol.pop(0)
            self.low_vol.append(self.data.iloc[self.t, :][lowcol] - self.data.iloc[(self.t - 1), :][
                lowcol])  # add the diferrence between cureent CLose Value and prior Close Value
            result += self.low_vol
        elif self.args.allprices2:
			self.history.pop(0) # method takes a single argument (index) and removes the element present at that index from the list. ...
			self.history.append(self.data.iloc[self.t, :][datacol] - self.data.iloc[(self.t - 1), :][
            datacol])  # add the diferrence between cureent CLose Value and prior Close Value
			result +=self.history	
			
            self.open_vol.pop(0)
            close_t = self.data.iloc[self.t, :][datacol]
            self.open_vol.append(self.data.iloc[self.t, :][opencol] - close_t)  # add the diferrence
            result += self.open_vol

            self.high_vol.pop(0)
            self.high_vol.append(self.data.iloc[self.t, :][highcol]  - close_t)  # add the diferrence
            result += self.high_vol

            self.low_vol.pop(0)
            self.low_vol.append(self.data.iloc[self.t, :][lowcol]  - close_t)  # add the diferrence
            result += self.low_vol
			
		elif self.args.allprices3:
			self.history.pop(0) # method takes a single argument (index) and removes the element present at that index from the list. ...
			self.history.append(log(self.data.iloc[self.t-1, :][datacol]/self.data.iloc[(self.t), :][datacol]))  
			result +=self.history	
			
            self.open_vol.pop(0)
            close_t = self.data.iloc[self.t, :][datacol]
            self.open_vol.append(log(self.data.iloc[self.t-1, :][opencol]/self.data.iloc[(self.t), :][opencol]))  
			result += self.open_vol

            self.high_vol.pop(0)
            self.high_vol.append(log(self.data.iloc[self.t-1, :][highcol]/self.data.iloc[(self.t), :][highcol]))  
			result += self.high_vol

            self.low_vol.pop(0)
            self.low_vol.append(log(self.data.iloc[self.t-1, :][lowcol]/self.data.iloc[(self.t), :][lowcol])) 
            result += self.low_vol
		else
			self.history.pop(0) # method takes a single argument (index) and removes the element present at that index from the list. ...
			self.history.append(self.data.iloc[self.t, :][datacol] - self.data.iloc[(self.t - 1), :][
            datacol])  # add the diferrence between cureent CLose Value and prior Close Value
			result +=self.history
			
		return result
    def step(self, act):
        datacol = '<CLOSE>'
        tickercol = '<TICKER>'
        datacol_vol  = '<VOL>'
        opencol = '<OPEN>'
        highcol = '<HIGH>'
        lowcol = '<LOW>'
        reward = 0  # stay
        profit = 0
        buy = 0
        sell = 0
        position_val=0
        # act = 0: stay, 1: buy, 2: sell

        ticker = self.data.iloc[self.t, :][tickercol]
        if act == 1:  # buy
            if self.position == 0:  # если не в позиции то добпвляем лонг с "+"
                self.position = self.data.iloc[self.t, :][datacol]
                buy = self.position
                # add value to long positions  (we enter at the candle close)
            elif self.position > 0:  # есть открытая длинная позиция
                reward = -100
            else:
                profit = (-self.data.iloc[self.t, :][datacol] - self.position)
                self.profits += profit
                buy = self.data.iloc[self.t, :][datacol]
                self.position = 0
                # Есть открытая короткая позиция

        elif act == 2:  # sell
            if self.position == 0:  # если не в позиции то добпвляем Short с "-"
                self.position = -self.data.iloc[self.t, :][datacol]
                # add value to long positions  (we enter at the candle close)
                sell = - self.position
            elif self.position < 0:  # есть открытая короткая позиция
                reward = -100
            else:
                profit = (self.data.iloc[self.t, :][datacol] - self.position)
                # Есть открытая короткая позиция
                self.profits += profit  # Remember profit
                sell = self.data.iloc[self.t, :][datacol]
                self.position = 0
        if self.position < 0:
            position_val = (-self.data.iloc[self.t, :][datacol] - self.position)
        elif  self.position > 0:
            position_val = (self.data.iloc[self.t, :][datacol] - self.position)
            # set next time
        #!!! self.t += 1
		result = self.gotnextstate(self)	
		
        if self.args.stop > 0:
            if self.position < 0:
                lowest_position_val = (-1*self.position - self.data.iloc[self.t, :][highcol] )
            elif self.position > 0:
                lowest_position_val = (self.data.iloc[self.t, :][lowcol] - self.position)
            else:
                lowest_position_val = 0
            if -1 * self.args.stop > lowest_position_val:
                profit = self.args.stop*1.1
                reward = lowest_position_val
                position_val = 0
                self.position = 0
				
		result = [position_val + 0.0] + result		
		# clipping reward
        if profit != 0:
            reward = profit
        elif position_val < -self.args.stop/2:
            reward += position_val*3

        if ticker != self.data.iloc[self.t, :][tickercol]:
            for _ in range(self.history_t):  # step(0) - act = 0: stay
                result = [0.0] +	self.gotnextstate(self)	
            reward = 0
            position_val = 0
            self.position = 0
            profit = position_val
		
        return np.array(result), reward, self.done, buy, sell, profit  # obs, reward, done,profit
